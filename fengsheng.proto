syntax = "proto3";
option go_package = "protos/;protos";

enum phase {
  Draw_Phase       = 0; // 摸牌阶段
  Main_Phase       = 1; // 出牌阶段
  Send_Start_Phase = 2; // 情报传递阶段开始时
  Send_Phase       = 3; // 传递阶段
  Fight_Phase      = 4; // 争夺阶段
  Receive_Phase    = 5; // 接收阶段
}

enum card_type {
  Cheng_Qing = 0; // 澄清
  Shi_Tan    = 1; // 试探
  Wei_Bi     = 2; // 威逼
  Li_You     = 3; // 利诱
  Ping_Heng  = 4; // 平衡
  Po_Yi      = 5; // 破译
  Jie_Huo    = 6; // 截获
  Diao_Bao   = 7; // 掉包
  Wu_Dao     = 8; // 误导
}

enum color {
  Black = 0; // 对于身份，则是绿色（神秘人）；对于卡牌，则是黑色
  Red = 1;   // 红色
  Blue = 2;  // 蓝色
}

// 神秘人任务
enum secret_task {
  Killer    = 0; // 你的回合中，一名红色和蓝色情报合计不少于2张的人死亡
  Stealer   = 1; // 你的回合中，有人宣胜，则你代替他胜利
  Collector = 2; // 你获得3张红色情报或者3张蓝色情报
}

enum direction {
  Up    = 0; // 向上
  Left  = 1; // 向左
  Right = 2; // 向右
}

// 卡牌的结构体
message card {
  uint32         card_id       = 1; // 卡牌ID
  repeated color card_color    = 2; // 卡牌颜色（因为可能有双色卡，所以用了repeated）
  direction      card_dir      = 3; // 卡牌上的箭头方向
  card_type      card_type     = 4; // 卡牌类型
  repeated color who_draw_card = 5; // （试探卡）哪个身份的人摸1张牌（那么另外的身份一定是弃1张牌）
  bool           can_lock      = 6; // 是否有锁定标记
}

// 通知客户端：初始化游戏
message init_toc {
  uint32      player_count = 1; // 玩家总人数（包括你）
  color       identity     = 2; // 你的身份
  secret_task secret_task  = 3; // （你的身份是神秘人时）你的机密任务
}

// 通知客户端：某个玩家摸了一张卡
message add_card_toc {
  uint32        player_id          = 1; // 自己是0，右手方第一名玩家是1，以此类推
  uint32        unknown_card_count = 2; // 背面朝上的牌的数量（用于其它人摸牌，你看不到）
  repeated card cards              = 3; // 摸到的卡牌
}

// 请求使用试探
message use_shi_tan_tos {
  uint32 card_id   = 1; // 卡牌ID
  uint32 player_id = 2;
  uint32 seq       = 3;
}

// 通知客户端，谁对谁使用了试探
message use_shi_tan_toc {
  uint32 player_id        = 1; // 使用者
  uint32 target_player_id = 2; // 被使用者
  uint32 card_id          = 3; // 此时，只有使用者能看到这个id，其他人都是0
}

// 向被试探者展示试探，并等待回应
message show_shi_tan_toc {
  uint32 player_id        = 1; // 使用者
  uint32 target_player_id = 2; // 被使用者
  card   card             = 3; // 只有自己是使用者或者被使用者时，这个字段才会有值，否则为null/nil
  uint32 waiting_second   = 4; // 读多少秒
  uint32 seq              = 5;
}

// 被试探者执行试探
message execute_shi_tan_tos {
  repeated uint32 card_id = 1; // 摸牌或者弃牌但是没牌，就发送空数组。有牌弃就发送弃的牌的id。
  uint32          seq = 2;
}

message execute_shi_tan_toc {
  uint32 player_id    = 1; // 被试探者
  bool   is_draw_card = 2; // 若他选择了摸牌，则为true。（摸了牌和弃了牌是另外的协议）
}

// 通知客户端，牌堆的剩余数量
message sync_deck_num_toc {
  uint32 num      = 1; // 剩余数量
  bool   shuffled = 2; // 是否发生了洗牌
}

// 通知客户端，牌从谁的手牌被弃掉
message discard_card_toc {
  uint32        player_id = 1;
  repeated card cards     = 2;
}

// 通知客户端，到谁的哪个阶段了
message notify_phase_toc {
  uint32           current_player_id      = 1; // 当前回合玩家
  phase            current_phase          = 2; // 当前阶段
  uint32           intelligence_player_id = 3; // 情报在谁面前（只有传递、争夺、接收阶段有效）
  direction        message_card_dir       = 4; // 情报传递方向（只有传递、争夺、接收阶段有效）
  card             message_card           = 5; // 在某些情况下，正在传递的情报应该正面向上，这时候就应该有这个字段
  repeated uint32  lock_player_ids        = 6; // 被锁定的玩家ID
  uint32           waiting_player_id      = 7; // 读秒的玩家ID
  uint32           waiting_second         = 8; // 读多少秒
  uint32           seq                    = 9; // 只有当自己需要读秒时，这个字段才有值
}

// 请求结束出牌阶段，进入情报传递阶段
message end_main_phase_tos {
  uint32 seq = 1;
}

// 请求使用利诱
message use_li_you_tos {
  uint32 card_id   = 1; // 卡牌ID
  uint32 player_id = 2;
  uint32 seq       = 3;
}

// 通知客户端使用利诱的结果
message use_li_you_toc {
  uint32 player_id        = 1; // 使用者
  uint32 target_player_id = 2; // 被使用者
  card   li_you_card      = 3; // 使用的这张利诱牌
  card   message_card     = 4; // 利诱翻出来的牌。如果牌堆和弃牌堆全用完了，则为null/nil
  bool   join_into_hand   = 5; // 是否改为加入使用者手牌
}

// 请求使用平衡
message use_ping_heng_tos {
  uint32 card_id   = 1; // 卡牌ID
  uint32 player_id = 2;
  uint32 seq       = 3;
}

// 通知客户端使用利诱的结果
message use_ping_heng_toc {
  uint32        player_id            = 1; // 使用者
  uint32        target_player_id     = 2; // 被使用者
  card          ping_heng_card       = 3; // 使用的这张利诱牌
  repeated card discard_cards        = 4; // 使用者弃掉的牌。（平衡摸的三张牌直接发add_card_toc协议）
  repeated card target_discard_cards = 5; // 被使用者弃掉的牌。（平衡摸的三张牌直接发add_card_toc协议）
}

// 请求使用平衡
message use_wei_bi_tos {
  uint32    card_id   = 1; // 卡牌ID
  uint32    player_id = 2;
  card_type want_type = 3; // 声明的卡牌类型（截获/误导/调包/澄清）
  uint32    seq       = 4;
}

// 威逼等待给牌
message wei_bi_wait_for_give_card_toc {
  card      card             = 1; // 使用的那张威逼卡牌
  uint32    player_id        = 2;
  uint32    target_player_id = 3;
  card_type want_type        = 4; // 声明的卡牌类型（截获/误导/调包/澄清）
  uint32    waiting_second   = 5; // 读多少秒
  uint32    seq              = 6;
}

// 威逼给牌
message wei_bi_give_card_tos {
  uint32 card_id = 1; // 给出去的卡牌ID
  uint32     seq = 2;
}

// 通知所有人威逼给牌
message wei_bi_give_card_toc {
  uint32 player_id        = 1;
  uint32 target_player_id = 2;
  card   card             = 3; // 给出去的卡牌
}

// 通知所有人威逼的牌没有，展示所有手牌
message wei_bi_show_hand_card_toc {
  card          card             = 1; // 使用的那张威逼卡牌
  uint32        player_id        = 2;
  uint32        target_player_id = 3;
  repeated card cards            = 4; // 展示所有手牌，只有使用者能看到，其他人收到的都是空数组
}

// 请求使用澄清
message use_cheng_qing_tos {
  uint32 card_id        = 1; // 卡牌ID
  uint32 player_id      = 2;
  uint32 target_card_id = 3;
  uint32 seq            = 4;
}

// 通知所有人澄清
message use_cheng_qing_toc {
  card   card             = 1;
  uint32 player_id        = 2;
  uint32 target_player_id = 3;
  uint32 target_card_id   = 4;
}

// 请求传情报
message send_message_card_tos {
  uint32          card_id          = 1;
  uint32          target_player_id = 2;
  repeated uint32 lock_player_id   = 3;
  uint32          seq              = 4;
}

// 选择是否接收情报
message choose_whether_receive_tos {
  bool   receive = 1;
  uint32 seq     = 2;
}

// 通知客户端谁死亡了
message notify_die_toc {
  uint32 player_id = 1;
  bool   lose_game = 2; // true表示因为轮到传递情报时没情报传了导致输掉游戏
}
